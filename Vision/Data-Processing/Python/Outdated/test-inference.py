#! /usr/local/bin/python
# This is the inference algorithm to determine if the attributes at the selected 
# points are up to par with the known target. I will pepper this code with comments
# for ease of understanding. 

import cv, cv2, numpy, math, edge, contrast, convert, random, MonteCarlo, array
from collections import Counter
lines = edge.main() #REMEMBER THIS VARIABLE!!!!
#print lines

def parallel(lines):
	good_lines = [line for line in lines if (line[2] - line[0]) != 0]	
	sort_slopes = sorted(good_lines, key = slope)
	return sort_slopes 		
		
def slope(line):
	return float(line[3] - line[1]) / float(line [2] - line[0])

#we are going to assume that q is our image

#DO NOT FORGET TO REMOVE ERROR CHECKING PARTS OF CODE!!!
x = cv2.VideoCapture()
k = []
q = contrast.main()
k = q#q is name of working contrast frame passed from module

slopearray = []
for line in parallel(lines[0]):
	orderedSlope = slope(line)
	slopearray.append(orderedSlope)


#below I find value from orderedSlope
parr = []
pos = set(slopearray)
for j in pos:
	l = slopearray.count(j)
	if l > 1:
		for n in xrange(l):
			parr.append(j)

#use parr as edges to compare
#start contrast search here, k is contrast frame, parr is parallel lines 

##############!!!!!NEEDS REPAIR!!!!!###############

###THIS FUNCTION MUST BE LOOPED (AFTER FUNCTION DECLARATION) TO TEST ALL POSSIBLE TARGETS###

def MonteCarloVision(k, parr):#this program does the actual comparisions on random points
#and determines jointness of k and parr
	MC = MonteCarlo.MonteCarlo() #change MC to operate between parr bounds
	a = MC#MC generates random coords, we only need 1st element here (element 0)		
	for x in MC:
		elem = k[a[0]]
		new = elem[1]#Here we finally have the whole frame we were looking for...
		#need to change 1?
		#print new#now we can finally see it....
		#Must test coordinates in line generated by PARR in the range of endpoint to endpoint
		rangeA = Counter(range(256)) #range(n) is subsituted by any list
		rangeB = Counter(range(120))
		AA = rangeA - rangeB
#see http://stackoverflow.com/questions/2070643/subtracting-two-lists-in-python for details
		print AA
		try:#may still need to re-adjust if stmnt below	...any, all?
			if all(new) in AA:#if the position of the element is between bound A and bound B...
				#out = [k[a], True]
				return new#must be broken down to single data value or simple list
		except:
			#out = [k[a], False]
			return None
##############!!!!!NEEDS REPAIR!!!!!###############
#need to convert new to done
done = []#should be [contrast point, slope of line, coord of point]
mv = MonteCarloVision(k, parr)
done.append(mv) #set function equal to array and append outside of function
#print done

########################!!!!!SPECIAL REMINDER!!!!!##########################
#Dont forget to make the edge detection and the contrast processing take exactly one frame per loop of program
#Dont forget to make a final program that imports this one and the communications architecture and loops it
############################################################################

####!!FINAL EVALUATIONS OF DATA HERE!!####
def contrastProbgen(done):
	problistA = [] #made of: [[done], P]
	try:
		if done[0] >= 256:
			problistA.append(done[3])
			problistA.append('P = 1.0')
	
		if done[0] >= 200 and done[0] < 256:
			problistA.append(done[3])
			problistA.append('P = 0.8')
	
		if done[0] >= 150 and done [0] < 200:
			problistA.append(done[3])
			problistA.append('P = 0.6')

		if done[0] >= 100 and done[0] < 150:
			problistA.append(done[3])
			problistA.append('P = 0.4')

		if done[0] >= 50 and done[0] < 100:
			problistA.append(done[3])
			problistA.append('P = 0.2')

		if done[0] < 50:
			return none
	except:
		print 'ERROR IN TRY BLOCK'
		return None
	print problistA

contrastProbgen(done)

def MonteCarloCMP():
	pass #this function is going to verify that each randomly tested point in an area is similar
	#this is a basic form of gradient analysis
def FinalCMP(problistA):
	try:
		if problistA[1] >= 0.6:
			return True, problistA[0]
	except:
		if problistA[1] == None:		
			print 'ERROR IN TRY BLOCK'
			return None
	finally:
		if problistA[1] < 0.6:
			return False
#Final output must be True or False
####!!FINAL EVALUATIONS OF DATA HERE!!####

